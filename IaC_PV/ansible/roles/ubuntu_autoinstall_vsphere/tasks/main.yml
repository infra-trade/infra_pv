---
# 0) Facts del controlador
- name: Gather facts on localhost
  setup:
  delegate_to: localhost
  become: false

# 1) Probar conexión a vCenter (sanity check) — robusto
- name: Probar conexión a vCenter (sanity check)
  community.vmware.vmware_about_info:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    validate_certs: "{{ vcenter_validate_certs }}"
    port: 443
  register: _vc_info

- name: Validar respuesta de vCenter (no fallará si el módulo ya lanzó error)
  assert:
    that:
      - (_vc_info.failed | default(false) | bool) == false
    success_msg: "Conexión a vCenter OK."
    fail_msg: "Conexión a vCenter falló (revisa usuario/clave/dominio o permisos)."

# 1.1) Verificar datacenter/datastore antes de tocar ficheros/ISOs
- name: DEBUG vCenter scope (datacenter/datastore)
  debug:
    msg:
      datacenter: "{{ vcenter_datacenter }}"
      datastore: "{{ vcenter_datastore }}"

- name: Validar datacenter y datastore no vacíos
  assert:
    that:
      - (vcenter_datacenter | length) > 0
      - (vcenter_datastore  | length) > 0
    fail_msg: >
      Faltan 'vcenter_datacenter' o 'vcenter_datastore'.
      Verifica iac/ansible/group_vars/all.yml (o -e / vault) antes de continuar.

# 2) Instalar dependencias del SO según plataforma
- name: Instalar dependencias en OpenBSD
  package:
    name:
      - py3-pip
      - cdrtools      # provee mkisofs
      - xorriso
    state: present
  become: true
  when: ansible_facts['os_family'] == 'OpenBSD'

- name: Instalar dependencias en Debian/Ubuntu
  apt:
    name:
      - python3-pip
      - genisoimage   # provee mkisofs
      - xorriso
    state: present
    update_cache: true
  become: true
  when: ansible_facts['os_family'] == 'Debian'

- name: Instalar dependencias en RedHat/CentOS
  yum:
    name:
      - python3-pip
      - genisoimage
      - xorriso
    state: present
  become: true
  when: ansible_facts['os_family'] == 'RedHat'

# 3) Normalizar variables y banderas (evita problemas de tipos)
- name: Normalizar variables de ISO (strings)
  set_fact:
    _iso_url: "{{ ubuntu_iso_url | default('') | string }}"
    _iso_local: "{{ ubuntu_iso_local | default('') | string }}"
    _iso_existing: "{{ existing_datastore_iso | default('') | string }}"
    _iso_dir: "{{ datastore_iso_dir | default('iso') | string }}"

- name: Calcular banderas de origen de ISO
  set_fact:
    use_url: "{{ (_iso_url | length) > 0 }}"
    use_local: "{{ (_iso_local | length) > 0 }}"
    use_existing: "{{ (_iso_existing | length) > 0 }}"

- name: Validar que exista alguna fuente de ISO
  assert:
    that:
      - use_url or use_local or use_existing
    fail_msg: "Define ubuntu_iso_url o ubuntu_iso_local, o bien existing_datastore_iso ('[DATASTORE] carpeta/archivo.iso')."

# 4) Preparar nombre y path del ISO (cuando NO usamos existing)
- name: Inicializar variables de ISO calculadas
  set_fact:
    ubuntu_iso_filename: ""
    ubuntu_iso_local_path: ""
  when: not use_existing

- name: Calcular filename/local_path desde URL
  set_fact:
    ubuntu_iso_filename: "{{ _iso_url | basename }}"
    ubuntu_iso_local_path: "{{ lookup('env','HOME') }}/.cache/ansible/{{ _iso_url | basename }}"
  when:
    - not use_existing
    - use_url

- name: Calcular filename/local_path desde ruta local
  set_fact:
    ubuntu_iso_filename: "{{ _iso_local | basename }}"
    ubuntu_iso_local_path: "{{ _iso_local }}"
  when:
    - not use_existing
    - use_local

- name: Asegurar que filename/local_path quedaron definidos si no usamos existing
  assert:
    that:
      - ubuntu_iso_filename | length > 0
      - ubuntu_iso_local_path | length > 0
  when: not use_existing

# 5) Descargar ISO si viene por URL
- name: Descargar ISO Ubuntu si hay URL
  delegate_to: localhost
  when:
    - use_url
    - not use_existing
  get_url:
    url: "{{ _iso_url }}"
    dest: "{{ ubuntu_iso_local_path }}"
    mode: "0644"
    force: no

# 6) Preparar seed cloud-init local
- name: Preparar seed cloud-init local
  delegate_to: localhost
  file:
    path: "/tmp/seed-{{ seed_vm_name }}"
    state: directory
    mode: "0755"

# --- Gestión robusta de la llave pública ---
- name: Resolver ruta de la llave pública (expandir ~)
  delegate_to: localhost
  set_fact:
    _pubkey_path: "{{ (ssh_pubkey_path | default('~/.ssh/id_ed25519.pub') | string) | expanduser }}"

- name: Derivar ruta de la llave privada (si _pubkey_path termina en .pub)
  delegate_to: localhost
  set_fact:
    _privkey_path: "{{ _pubkey_path | regex_replace('\\.pub$', '') }}"

- name: Verificar existencia de la llave pública
  delegate_to: localhost
  stat:
    path: "{{ _pubkey_path }}"
  register: _pubkey_stat

- name: Crear directorio ~/.ssh si hace falta
  delegate_to: localhost
  file:
    path: "{{ _privkey_path | regex_replace('/[^/]+$', '') | default(lookup('env','HOME') + '/.ssh', true) }}"
    state: directory
    mode: "0700"
  when:
    - auto_create_ssh_key | default(true)
    - not _pubkey_stat.stat.exists | default(false)

- name: Generar llave SSH si no existe y está permitido
  delegate_to: localhost
  command: >
    ssh-keygen
    -t {{ (ssh_key_type | default('ed25519')) }}
    {% if (ssh_key_type | default('ed25519')) == 'rsa' %}-b {{ ssh_key_bits | default(4096) }}{% endif %}
    -N ""
    -f "{{ _privkey_path }}"
  args:
    creates: "{{ _privkey_path }}"
  when:
    - auto_create_ssh_key | default(true)
    - not _pubkey_stat.stat.exists | default(false)

- name: Re-verificar existencia de la llave pública tras posible generación
  delegate_to: localhost
  stat:
    path: "{{ _pubkey_path }}"
  register: _pubkey_stat_after

- name: Asegurar que la llave pública existe
  assert:
    that:
      - _pubkey_stat_after.stat.exists
      - _pubkey_stat_after.stat.isreg
    fail_msg: >
      No se encontró la llave pública en {{ _pubkey_path }}.
      Define 'ssh_pubkey_path' en group_vars/all.yml o permite crearla con 'auto_create_ssh_key: true'.

- name: Cargar llave pública (contenido)
  delegate_to: localhost
  slurp:
    src: "{{ _pubkey_path }}"
  register: _pubkey_data

- name: Guardar contenido de la llave pública en variable
  set_fact:
    ssh_pubkey_content: "{{ _pubkey_data.content | b64decode | trim }}"
# --- Fin gestión de llave pública ---

# 7) Calcular máscara en bits SIN filtro 'ipaddr'
- name: Descomponer netmask en octetos
  set_fact:
    _octs: "{{ guest_netmask | default('255.255.255.0') | string | split('.') | map('int') | list }}"

- name: Mapa de bits por octeto
  set_fact:
    _bitlen_map:
      0: 0
      128: 1
      192: 2
      224: 3
      240: 4
      248: 5
      252: 6
      254: 7
      255: 8

- name: Calcular prefix a partir del netmask
  set_fact:
    mask_bits: "{{ (_octs | map('extract', _bitlen_map) | list | sum) | int }}"

- name: Validar prefix calculado
  assert:
    that:
      - mask_bits >= 0
      - mask_bits <= 32
    fail_msg: "Netmask inválido: {{ guest_netmask }}"

# 8) Renderizar user-data/meta-data
- name: Renderizar user-data/meta-data
  delegate_to: localhost
  block:
    - name: user-data
      template:
        src: "templates/user-data.j2"
        dest: "/tmp/seed-{{ seed_vm_name }}/user-data"
        mode: "0644"
      vars:
        hostname: "{{ seed_vm_name }}"
        host_ip: "192.168.5.250"   # IP temporal para seed
        mask_bits: "{{ mask_bits }}"
        ssh_key: "{{ ssh_pubkey_content }}"
    - name: meta-data
      template:
        src: "templates/meta-data.j2"
        dest: "/tmp/seed-{{ seed_vm_name }}/meta-data"
        mode: "0644"
      vars:
        hostname: "{{ seed_vm_name }}"

# 9) Crear seed ISO (NoCloud) con mkisofs
- name: Crear seed ISO (NoCloud) con mkisofs
  delegate_to: localhost
  command:
    cmd: >
      mkisofs -output /tmp/seed-{{ seed_vm_name }}.iso
      -V cidata -J -R
      /tmp/seed-{{ seed_vm_name }}/user-data
      /tmp/seed-{{ seed_vm_name }}/meta-data
    creates: "/tmp/seed-{{ seed_vm_name }}.iso"

# 10) Asegurar carpeta en el datastore (por si no existe)
- name: Crear carpeta de destino en datastore ({{ _iso_dir }})
  community.vmware.vsphere_file:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    validate_certs: "{{ vcenter_validate_certs }}"
    port: 443
    datacenter: "{{ vcenter_datacenter }}"
    datastore: "{{ vcenter_datastore }}"
    datastore_name: "{{ vcenter_datastore }}"
    path: "{{ _iso_dir }}"          # sin "/" inicial
    state: directory
  register: _mk_dir
  failed_when: false                 # si falla (404) seguimos; el upload puede crearla
  changed_when: "_mk_dir is changed"

# 11) Subir seed ISO al datastore
- name: Subir seed ISO al datastore
  community.vmware.vsphere_copy:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    validate_certs: "{{ vcenter_validate_certs }}"
    port: 443
    src: "/tmp/seed-{{ seed_vm_name }}.iso"
    datacenter: "{{ vcenter_datacenter }}"
    datastore: "{{ vcenter_datastore }}"
    datastore_name: "{{ vcenter_datastore }}"
    path: "{{ _iso_dir }}/seed-{{ seed_vm_name }}.iso"

# 12) Crear VM seed y montar ISOs
- name: Crear VM seed y montar ISOs
  community.vmware.vmware_guest:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    validate_certs: "{{ vcenter_validate_certs }}"
    port: 443
    datacenter: "{{ vcenter_datacenter }}"
    cluster: "{{ vcenter_cluster }}"
    folder: "{{ vm_folder | default(omit) }}"
    name: "{{ seed_vm_name }}"
    state: poweredon
    guest_id: "ubuntu64Guest"
    hardware:
      memory_mb: "{{ vm_ram_mb }}"
      num_cpus: "{{ vm_cpu }}"
      scsi: paravirtual
      boot_firmware: efi
      boot_order:
        - cdrom
        - disk
        - ethernet
    networks:
      - name: "{{ vcenter_network }}"
    disk:
      - size_gb: "{{ vm_disk_gb }}"
        type: thin
        autoselect_datastore: false
        datastore: "{{ vcenter_datastore }}"
    cdrom:
      - type: iso
        iso_path: >-
          {{
            use_existing
              | ternary(
                  _iso_existing,
                  "[{{ vcenter_datastore }}] {{ _iso_dir }}/{{ ubuntu_iso_filename }}"
                )
          }}
        controller_number: 0
        unit_number: 0
      - type: iso
        iso_path: "[{{ vcenter_datastore }}] {{ _iso_dir }}/seed-{{ seed_vm_name }}.iso"
        controller_number: 0
        unit_number: 1
    wait_for_ip_address: no

# 13) Espera simple a que finalice autoinstall (ajusta según tu entorno)
- name: Espera razonable a que finalice autoinstall
  pause:
    minutes: 15

# 14) Desmontar CDROMs y apagar VM seed
- name: Desmontar CDROMs
  community.vmware.vmware_guest:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    validate_certs: "{{ vcenter_validate_certs }}"
    port: 443
    datacenter: "{{ vcenter_datacenter }}"
    name: "{{ seed_vm_name }}"
    cdrom:
      - type: none
        state: present
        controller_number: 0
        unit_number: 0
      - type: none
        state: present
        controller_number: 0
        unit_number: 1

- name: Apagar VM seed
  community.vmware.vmware_guest:
    hostname: "{{ vcenter_hostname }}"
    username: "{{ vcenter_username }}"
    password: "{{ vcenter_password }}"
    validate_certs: "{{ vcenter_validate_certs }}"
    port: 443
    datacenter: "{{ vcenter_datacenter }}"
    name: "{{ seed_vm_name }}"
    state: poweredoff
    state_change_timeout: 1200